<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Collaborative Adventure</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
body {
font-family: 'Inter', sans-serif;
overflow: hidden;
}
#story-log {
scroll-behavior: smooth;
}
.story-paragraph {
opacity: 0;
transform: translateY(20px);
animation: fadeIn 0.5s ease-out forwards;
}
@keyframes fadeIn {
to {
opacity: 1;
transform: translateY(0);
}
}
</style>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen antialiased">

<!-- Header -->
<header class="bg-gray-800 shadow-lg p-3 z-10">
    <div class="container mx-auto flex justify-between items-center">
        <h1 class="text-xl font-bold text-indigo-400">Collaborative Adventure</h1>
        <div class="text-right text-xs">
            <p>User ID: <span id="user-id" class="font-mono bg-gray-700 px-2 py-1 rounded">...</span></p>
            <p>App ID: <span id="app-id" class="font-mono bg-gray-700 px-2 py-1 rounded">...</span></p>
        </div>
    </div>
</header>

<!-- Main Content -->
<main class="flex-1 container mx-auto p-4 flex flex-col overflow-hidden max-w-4xl">
    <!-- Story Log -->
    <div id="story-log" class="flex-1 bg-gray-800/50 rounded-lg p-6 overflow-y-auto mb-4 border border-gray-700 shadow-inner">
        <!-- Story paragraphs will be injected here -->
    </div>

    <!-- Choices & Status -->
    <div id="controls-container" class="h-48 flex flex-col justify-center">
        <div id="choices-container" class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <!-- Choice buttons will be injected here -->
        </div>
        <div id="status-container" class="text-center py-4 text-gray-400">
            <!-- Status messages will be shown here -->
        </div>
    </div>
</main>

<!-- Footer with Reset Button -->
<footer class="p-4 bg-gray-900 border-t border-gray-800">
     <div class="container mx-auto flex justify-center">
        <button id="reset-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg transition duration-300 shadow-md">
            Reset Adventure
        </button>
     </div>
</footer>

<!-- Firebase and Game Logic -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, onSnapshot, setDoc, updateDoc, deleteDoc, serverTimestamp, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Configuration (Provided by Environment) ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-adventure-app';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    // --- DOM Elements ---
    const storyLog = document.getElementById('story-log');
    const choicesContainer = document.getElementById('choices-container');
    const statusContainer = document.getElementById('status-container');
    const resetButton = document.getElementById('reset-button');
    const userIdSpan = document.getElementById('user-id');
    const appIdSpan = document.getElementById('app-id');

    // --- Firebase Initialization ---
    let app, auth, db, userId;
    let storyDocRef;
    let unsubscribeStory; // To detach the listener later

    // --- Game State ---
    let isProcessing = false; // Prevents multiple submissions

    // --- Main Initialization ---
    async function main() {
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            await authenticateUser();

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    userIdSpan.textContent = userId.substring(0, 8) + '...';
                    appIdSpan.textContent = appId;
                    
                    storyDocRef = doc(db, `/artifacts/${appId}/public/data/adventure`, "story");
                    
                    if (unsubscribeStory) unsubscribeStory();
                    unsubscribeStory = onSnapshot(storyDocRef, handleStoryUpdate, handleError);
                    
                } else {
                    console.log("User is signed out.");
                    statusContainer.textContent = "Authentication failed. Please refresh.";
                }
            });

        } catch (e) {
            console.error("Initialization failed:", e);
            statusContainer.textContent = "Error connecting to the adventure. Please check the console.";
        }

        resetButton.addEventListener('click', resetGame);
        choicesContainer.addEventListener('click', handleChoiceClick);
    }

    async function authenticateUser() {
        try {
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Authentication Error: ", error);
        }
    }
    
    // --- Firestore Handlers ---
    
    function handleStoryUpdate(docSnap) {
        isProcessing = false;
        if (docSnap.exists()) {
            const storyData = docSnap.data();
            renderStory(storyData);
        } else {
            console.log("No story found. Initializing a new one.");
            initializeStory();
        }
    }

    function handleError(error) {
        console.error("Error fetching story:", error);
        statusContainer.textContent = "Failed to load the story. See console for details.";
    }

    // --- Game Logic Functions ---

    async function initializeStory() {
        const startParagraph = {
            text: "The adventure begins at the edge of a whispering wood, a gnarled path disappearing into the shadows.",
            authorId: "system",
            timestamp: serverTimestamp()
        };
        const startChoices = [
            "Venture into the woods.",
            "Follow the sparkling river downstream.",
            "Set up camp for the night and observe."
        ];

        const initialStory = {
            paragraphs: [startParagraph],
            currentChoices: startChoices,
            isComplete: false,
        };

        try {
            await setDoc(storyDocRef, initialStory);
        } catch (e) {
            console.error("Failed to initialize story:", e);
        }
    }

    async function handleChoiceClick(event) {
        if (isProcessing || !event.target.matches('.choice-button')) return;
        isProcessing = true;

        const choiceText = event.target.dataset.choice;
        
        // Render choice immediately for responsiveness
        renderStatus("You chose: '" + choiceText + "'. Awaiting the next chapter...");
        clearChoices();

        // Update Firestore with the chosen paragraph
        const newParagraph = {
            text: choiceText,
            authorId: userId,
            timestamp: serverTimestamp()
        };

        try {
            await updateDoc(storyDocRef, {
                paragraphs: arrayUnion(newParagraph),
                currentChoices: []
            });
            // After the update, onSnapshot will trigger a re-render.
            // We then call the AI to generate the next step.
            await generateNextStep();
        } catch(e) {
            console.error("Error making a choice: ", e);
            isProcessing = false;
        }
    }

    // --- Gemini API Call ---
    async function generateNextStep() {
        renderStatus("The storyteller is pondering the next chapter...");
        
        const docSnap = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js").then(mod => mod.getDoc(storyDocRef));

        if (!docSnap.exists()) return;

        const storyData = docSnap.data();
        const storyHistory = storyData.paragraphs.map(p => p.text).join('\n\n');

        const systemPrompt = `You are a collaborative storytelling AI for a choose-your-own-adventure game. 
        Your task is to continue the story based on the history provided. 
        Write one new, engaging paragraph that follows the last choice. 
        Then, generate three new, distinct, and creative choices for the players to vote on next. 
        Respond ONLY in JSON format. Do not add any introductory text.`;
        
        const userQuery = `Continue this story:\n\n${storyHistory}`;

        const payload = {
            contents: [{ parts: [{ text: userQuery }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        nextParagraph: { type: "STRING" },
                        choices: {
                            type: "ARRAY",
                            items: { type: "STRING" }
                        }
                    },
                    required: ["nextParagraph", "choices"]
                }
            }
        };

        const apiKey = "";
        const apiUrl = `https://generativelace.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API call failed with status: ${response.status}`);
            }

            const result = await response.json();
            
            const generatedPart = result.candidates[0].content.parts[0].text;
            const parsedResult = JSON.parse(generatedPart);

            const { nextParagraph, choices } = parsedResult;

            if (!nextParagraph || !choices || choices.length === 0) {
                throw new Error("Invalid response from storyteller AI.");
            }

            const aiParagraph = {
                text: nextParagraph,
                authorId: "storyteller",
                timestamp: serverTimestamp()
            };

            await updateDoc(storyDocRef, {
                paragraphs: arrayUnion(aiParagraph),
                currentChoices: choices
            });

        } catch (error) {
            console.error("Error generating next step:", error);
            statusContainer.textContent = "The storyteller is confused. Please try resetting the adventure.";
            // Restore choices on failure
             await updateDoc(storyDocRef, { currentChoices: ["Try again: Delve deeper.", "Try again: Retreat.", "Try again: Look around."] });
        } finally {
            isProcessing = false;
        }
    }
    
    async function resetGame() {
        if (confirm("Are you sure you want to reset the entire adventure for everyone?")) {
            renderStatus("A new story is beginning...");
            clearChoices();
            clearStory();
            try {
                 await deleteDoc(storyDocRef);
                 await initializeStory(); // This will trigger onSnapshot and re-render
            } catch(e) {
                console.error("Failed to reset game:", e);
            }
        }
    }
    
    // --- DOM Manipulation ---

    function renderStory(storyData) {
        clearStory();
        storyData.paragraphs.forEach(p => {
            const pElem = document.createElement('div');
            pElem.classList.add('mb-4', 'story-paragraph');

            const authorSpan = document.createElement('span');
            authorSpan.className = "block text-xs font-semibold mb-1";
            
            if (p.authorId === "system") {
                authorSpan.textContent = "The Beginning";
                authorSpan.className += " text-indigo-400";
            } else if (p.authorId === "storyteller") {
                authorSpan.textContent = "Storyteller";
                authorSpan.className += " text-green-400";
            } else {
                authorSpan.textContent = `Player: ${p.authorId.substring(0, 8)}...`;
                authorSpan.className += " text-amber-400";
            }
            
            const textElem = document.createElement('p');
            textElem.textContent = p.text;
            textElem.className = "text-gray-200";

            pElem.appendChild(authorSpan);
            pElem.appendChild(textElem);
            storyLog.appendChild(pElem);
        });
        
        storyLog.scrollTop = storyLog.scrollHeight;
        
        clearChoices();

        if (isProcessing) {
            renderStatus("Processing choice...");
        } else if (storyData.currentChoices && storyData.currentChoices.length > 0) {
            renderChoices(storyData.currentChoices);
            renderStatus("What happens next? Make a choice!");
        } else if (!storyData.isComplete) {
            renderStatus("Waiting for the next chapter...");
        } else {
            renderStatus("The End.");
        }
    }

    function renderChoices(choices) {
        clearChoices();
        choices.forEach(choice => {
            const button = document.createElement('button');
            button.textContent = choice;
            button.dataset.choice = choice;
            button.className = 'choice-button bg-indigo-600 hover:bg-indigo-500 text-white font-semibold py-3 px-4 rounded-lg transition duration-300 shadow-lg transform hover:scale-105';
            choicesContainer.appendChild(button);
        });
    }
    
    function renderStatus(message) {
        statusContainer.innerHTML = `<p class="italic">${message}</p>`;
    }
    
    function clearStory() {
        storyLog.innerHTML = '';
    }

    function clearChoices() {
        choicesContainer.innerHTML = '';
    }

    // --- Start the App ---
    main();

</script>

</body>
</html>